<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Ospătar - Gestionare Mese</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      background-color: #111827;
      color: #fff;
      font-family: Arial, sans-serif;
      margin: 0; padding: 1rem;
      min-height: 100vh;
    }
    .btn {
      background-color: #f49032;
      padding: 8px 16px;
      border-radius: 6px;
      color: #fff;
      cursor: pointer;
      border: none;
    }
    .btn:hover {
      background-color: #d35400;
    }
    .table-box {
      border: 1px solid #f49032;
      margin-bottom: 1rem;
      padding: 1rem;
      border-radius: 6px;
    }
    .order-item {
      margin-left: 1rem;
    }
  </style>
</head>
<body>
  <h1 class="text-2xl font-bold mb-4 text-center">Aplicație Ospătar</h1>

  <div id="app" class="max-w-xl mx-auto">
    <!-- 1) Afișăm lista meselor open -->
    <div class="mb-4">
      <button class="btn" @click="fetchOpenTables">Vezi Mesele Deschise</button>
    </div>
    <div v-if="openTables.length > 0">
      <h2 class="text-xl font-bold mb-2">Mese Deschise:</h2>
      <ul>
        <li
          v-for="(tbl, idx) in openTables"
          :key="idx"
          class="table-box"
        >
          <div class="flex justify-between items-center">
            <strong>Masă: {{ tbl }}</strong>
            <button class="btn" @click="showOrdersForTable(tbl)">Vezi Comenzi</button>
          </div>
        </li>
      </ul>
    </div>
    <hr class="my-4 border-gray-600"/>

    <!-- 2) Introducere manuală tableCode -->
    <div class="mb-4">
      <label class="block mb-2">Introdu un cod de masă:</label>
      <input
        v-model="manualTableCode"
        type="text"
        placeholder="Ex: MASA16"
        class="px-4 py-2 rounded text-black"
      />
      <button class="btn ml-2" @click="showOrdersForTable(manualTableCode)">Caută</button>
    </div>

    <!-- 3) Afișare comenzi pt tableCode selectat -->
    <div v-if="currentTableCode" class="table-box">
      <h2 class="text-xl font-bold mb-2">Comenzi pentru: {{ currentTableCode }}</h2>
      <div v-if="orders.length === 0" class="italic">Nicio comandă găsită.</div>
      <div v-else>
        <div
          v-for="(ord, idx) in orders"
          :key="ord.docId"
          class="border-b border-gray-600 py-2"
        >
          <div class="font-bold">
            FirebaseID: {{ ord.docId }} | Client #{{ ord.clientNumber }}
          </div>
          <ul class="order-item">
            <li v-for="(item, iidx) in ord.items" :key="iidx">
              {{ item.name }} x {{ item.quantity }} – {{ (item.price * item.quantity).toFixed(2) }} Lei
            </li>
          </ul>
          <div class="font-bold mt-1 text-[#f49032]">
            Subtotal: {{ ord.total.toFixed(2) }} Lei
          </div>
        </div>
        <div class="mt-2 font-bold">Total masă: {{ tableSum }} Lei</div>
        <button class="btn mt-2" @click="finalizeTable(currentTableCode)">Finalizează Masa</button>
      </div>
    </div>
  </div>

  <!-- Firebase + Vue -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-app.js";
    import { 
      getFirestore, 
      collection, 
      query, 
      where, 
      getDocs, 
      doc, 
      updateDoc 
    } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-firestore.js";
    import { createApp } from "https://cdn.jsdelivr.net/npm/vue@3/dist/vue.esm-browser.js";

    /* Configurația Firebase (înlocuiește cu datele tale) */
    const firebaseConfig = {
      apiKey: "xxx",
      authDomain: "xxx.firebaseapp.com",
      projectId: "xxx",
      storageBucket: "xxx.appspot.com",
      messagingSenderId: "xxx",
      appId: "xxx",
      measurementId: "xxx"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    const waiterApp = createApp({
      data() {
        return {
          openTables: [],        // lista maselor "deschise" (fără duplicat)
          manualTableCode: '',   // pentru introducere manuală
          currentTableCode: null,// masa curentă selectată
          orders: [],            // comenzi pt masa curentă
        };
      },
      computed: {
        tableSum() {
          let sum = 0;
          this.orders.forEach(o => {
            sum += o.total;
          });
          return sum.toFixed(2);
        }
      },
      methods: {
        // Preia toate documentele cu status="open", adună distinct tableId
        async fetchOpenTables() {
          try {
            const cRef = collection(db, "orders");
            const qRef = query(cRef, where("status", "==", "open"));
            const snap = await getDocs(qRef);

            const tablesSet = new Set();
            snap.forEach(docSnap => {
              const data = docSnap.data();
              if (data.tableId) {
                tablesSet.add(data.tableId);
              }
            });

            this.openTables = Array.from(tablesSet);
          } catch (e) {
            console.error("Eroare la fetchOpenTables:", e);
          }
        },
        // Arată comenzile pt un tableCode (status="open")
        async showOrdersForTable(tableCode) {
          if (!tableCode) {
            alert("Cod masă invalid!");
            return;
          }
          this.currentTableCode = tableCode.trim().toUpperCase();
          this.orders = [];

          try {
            const cRef = collection(db, "orders");
            // Filtrăm doar comenzile open (dacă vrei să vezi și closed, elimină where("status","==","open")
            const qRef = query(
              cRef,
              where("tableId", "==", this.currentTableCode),
              where("status", "==", "open")
            );
            const snap = await getDocs(qRef);

            const allOrders = [];
            snap.forEach(docSnap => {
              const data = docSnap.data();
              allOrders.push({ docId: docSnap.id, ...data });
            });
            this.orders = allOrders;
          } catch (e) {
            console.error("Eroare la showOrdersForTable:", e);
          }
        },
        // Finalizează masa => setăm status="closed"
        async finalizeTable(tableCode) {
          if (!confirm(`Ești sigur că vrei să finalizezi masa ${tableCode}?`)) {
            return;
          }
          try {
            const cRef = collection(db, "orders");
            const qRef = query(
              cRef,
              where("tableId", "==", tableCode),
              where("status", "==", "open")
            );
            const snap = await getDocs(qRef);

            for (const docSnap of snap.docs) {
              const ref = doc(db, "orders", docSnap.id);
              await updateDoc(ref, { status: "closed" });
            }
            alert(`Masa ${tableCode} a fost închisă!`);

            // Golește
            this.currentTableCode = null;
            this.orders = [];
            this.fetchOpenTables(); // reîncărcăm lista meselor open
          } catch (e) {
            console.error("Eroare la finalizare masă:", e);
            alert("Eroare la finalizarea mesei!");
          }
        }
      },
      mounted() {
        // opțional, încărcăm direct openTables
        this.fetchOpenTables();
      }
    });

    waiterApp.mount('#app');
  </script>
</body>
</html>
