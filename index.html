<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Ospătar - Gestionare Mese</title>

  <!-- Tailwind CSS (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    body {
      background-color: #111827;
      color: #fff;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 1rem;
      min-height: 100vh;
    }
    .btn {
      background-color: #f49032;
      padding: 8px 16px;
      border-radius: 6px;
      color: #fff;
      cursor: pointer;
      border: none;
      transition: background-color 0.2s ease;
    }
    .btn:hover {
      background-color: #d35400;
    }

    /* Buton verde (gradient + shadow subtile) */
    .btn-green {
      background: linear-gradient(to right, #2ecc71, #27ae60);
      color: #fff;
      padding: 8px 16px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .btn-green:hover {
      transform: scale(1.05);
      box-shadow: 0 0 8px #2ecc71, 0 0 20px #27ae60;
    }

    /* Grid pentru 12 mese, 3 coloane */
    .grid-tables {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1rem;
      justify-items: center;
      max-width: 800px;
      margin: 0 auto;
    }
    .table-bubble {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      background-color: #1f2937;
      border: 2px solid #f49032;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      text-align: center;
      padding: 0.5rem;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .table-bubble:hover {
      transform: scale(1.05);
    }
    .occupied {
      background: linear-gradient(to bottom right, #f49032, #d35400);
      color: #111827;
      border-color: #f49032;
    }
    .animate-shake {
      animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both infinite;
    }
    @keyframes shake {
      10%, 90% { transform: translateX(-1px); }
      20%, 80% { transform: translateX(2px); }
      30%, 50%, 70% { transform: translateX(-4px); }
      40%, 60% { transform: translateX(4px); }
    }

    .order-box {
      border: 1px solid #e78c00;
      padding: 0.5rem;
      margin-bottom: 1rem;
      border-radius: 6px;
      background: #1f2937;
      position: relative;
    }
    .client-title {
      color: #f49032;
      font-weight: bold;
    }
    .highlight {
      background-color: rgba(244,144,50,0.3);
      transition: background-color 2s ease;
    }
  </style>
</head>
<body>
  <h1 class="text-2xl font-bold mb-4 text-center">Ospătar - Gestionare Mese</h1>

  <div id="app" class="max-w-4xl mx-auto">
    <!-- Buton: Afișează doar mesele ocupate sau toate -->
    <div class="mb-4 text-center">
      <button class="btn" @click="toggleShow">{{ toggleButtonLabel }}</button>
    </div>

    <!-- Grid Mese -->
    <div v-if="displayedTables.length" class="grid-tables">
      <div
        v-for="(tbl, idx) in displayedTables"
        :key="tbl.tableId"
        :class="[
          'table-bubble',
          { 'occupied': tbl.isOccupied },
          { 'animate-shake': tbl.hasNewOrder }
        ]"
        @click="bubbleClick(tbl)"
      >
        <div class="font-bold text-center text-sm">
          {{ tbl.tableId }}
        </div>
      </div>
    </div>
    <p v-else class="text-center text-gray-400">
      Nu există mese de afișat.
    </p>

    <hr class="my-4 border-gray-700"/>

    <!-- Afișare comenzi pentru masa selectată -->
    <div v-if="currentTableId" class="order-box">
      <h2 class="text-xl font-bold mb-2">{{ currentTableId }}</h2>
      <p v-if="currentSessionCode" class="text-gray-300 mb-2">
        Codul Comenzii: <strong>{{ currentSessionCode }}</strong>
      </p>

      <div v-if="orders.length === 0" class="italic mt-2">
        Nicio comandă deschisă găsită pentru această masă.
      </div>
      <div v-else>
        <!-- Grupare după clientNumber -->
        <div
          v-for="(clientData, cIdx) in clientsList"
          :key="cIdx"
          class="mb-3"
        >
          <div class="client-title">
            Client #{{ cIdx + 1 }}
          </div>

          <div
            v-for="(ord, oIdx) in clientData.orders"
            :key="ord.orderId"
            class="ml-4 mt-1"
          >
            <!-- Afisare comenzi -->
            <div class="text-sm text-gray-400 mb-1">
              <strong>Comanda #{{ oIdx + 1 }}</strong>

              <!-- Butonul apare doar dacă e "pending" -->
              <button
                class="btn-green ml-2"
                v-if="ord.orderStatus === 'pending'"
                @click="placeOrder(ord.orderId)"
              >
                Plasează Comanda
              </button>
            </div>

            <ul
              :class="[ 'ml-2', 'list-disc', { 'highlight': newOrderHighlight && ord.isNew } ]"
            >
              <li
                v-for="(item, iIdx) in ord.items"
                :key="iIdx"
              >
                {{ item.name }} x {{ item.quantity }}
                – {{ (item.price * item.quantity).toFixed(2) }} Lei
              </li>
            </ul>
          </div>
        </div>

        <div class="mt-2 font-bold text-[#f49032] text-lg">
          Total Masă: {{ totalTable }} Lei
        </div>
        <button class="btn mt-4" @click="finalizeTable(currentTableId)">
          Finalizează Masa
        </button>
      </div>
    </div>
  </div>

  <!-- Firebase + Vue -->
  <script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-app.js";
  import {
    getFirestore,
    collection,
    doc,
    getDoc,
    setDoc,
    updateDoc,
    onSnapshot,
    query,
    where,
    getDocs
  } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-firestore.js";
  import { createApp } from "https://cdn.jsdelivr.net/npm/vue@3/dist/vue.esm-browser.js";

  /* Configurare Firebase */
  const firebaseConfig = {
    apiKey: "AIzaSyBahkhy2GgUW2wM5dxghoVt2bv0-6ZyWq",
    authDomain: "restaurantapp-d0256.firebaseapp.com",
    projectId: "restaurantapp-d0256",
    storageBucket: "restaurantapp-d0256.firebasestorage.app",
    messagingSenderId: "275208346650",
    appId: "1:275208346650:web:f262b8ec49242d4b9945a3",
    measurementId: "G-F44TB27G17"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  const waiterApp = createApp({
    data() {
      return {
        // 12 mese
        twelveTables: Array.from({ length: 12 }, (_, i) => ({
          tableId: `Masa numărul ${i + 1}`,
          isOccupied: false,
          hasNewOrder: false,  // folosit pt. vibrație
          sessionCode: ""
        })),

        showOccupiedOnly: false,

        currentTableId: "",
        currentSessionCode: "",
        orders: [],

        newOrderHighlight: false,
        sessionCodeCache: new Map(),
        ordersSeen: new Set(),

        // ne păstrăm aici "unsubscribe" la subscriptii
        unsubscribeOrdersForCurrentTable: null,
        unsubscribeAllSessions: null,
        unsubscribeAllOrders: null
      };
    },
    computed: {
      // Buton toggle
      toggleButtonLabel() {
        return this.showOccupiedOnly
          ? "Vezi Toate Mesele"
          : "Vezi Mesele Deschise";
      },
      // Mese de afișat
      displayedTables() {
        if (this.showOccupiedOnly) {
          return this.twelveTables.filter(t => t.isOccupied);
        }
        return this.twelveTables;
      },
      // Grupare comenzi după clientNumber
      clientsList() {
        const map = {};
        for (const ord of this.orders) {
          const cNum = ord.clientNumber;
          if (!map[cNum]) {
            map[cNum] = [];
          }
          map[cNum].push(ord);
        }
        const result = [];
        for (const c of Object.keys(map)) {
          result.push({ clientNumber: c, orders: map[c] });
        }
        return result;
      },
      // Total masă
      totalTable() {
        let sum = 0;
        for (const ord of this.orders) {
          sum += ord.total;
        }
        return sum.toFixed(2);
      }
    },
    methods: {
      toggleShow() {
        this.showOccupiedOnly = !this.showOccupiedOnly;
      },

      /**
       * Real-time: Ascultăm direct toate sesiunile "active".
       * Resetăm mereu starea meselor și setăm care sunt ocupate + sessionCode.
       */
      subscribeActiveSessions() {
        const sessionsRef = collection(db, "sessions");
        const q = query(sessionsRef, where("status", "==", "active"));
        this.unsubscribeAllSessions = onSnapshot(
          q,
          (snapshot) => {
            // Reset la toate mesele (nu e strict necesar la fiecare update,
            // dar e o modalitate ușoară de a re-sincroniza totul)
            this.twelveTables.forEach((t) => {
              t.isOccupied = false;
              t.sessionCode = "";
              // NU resetăm hasNewOrder aici, o vom reseta doar la finalize, altfel
              // se poate pierde vibrația când e un update minor din sessions
            });

            snapshot.forEach((docSnap) => {
              const data = docSnap.data();
              const tableId = docSnap.id; // ex: "Masa numărul 1"
              const idx = this.twelveTables.findIndex(t => t.tableId === tableId);
              if (idx !== -1) {
                this.twelveTables[idx].isOccupied = true;
                this.twelveTables[idx].sessionCode = data.sessionCode || "";
              }
            });
          },
          (err) => {
            console.error("Eroare la onSnapshot sessions:", err);
            alert("Nu putem asculta sesiunile active în timp real!");
          }
        );
      },

      /**
       * Real-time: Ascultăm toate comenzile "open". Când apare o nouă comandă,
       * găsim masa aferentă (după sessionCode) și setăm hasNewOrder = true.
       */
      subscribeAllOpenOrders() {
        const ordersRef = collection(db, "orders");
        const q = query(ordersRef, where("status", "==", "open"));
        this.unsubscribeAllOrders = onSnapshot(
          q,
          (snapshot) => {
            snapshot.docChanges().forEach((change) => {
              // detectăm doar comenzile "adăugate" (new) sau reapărute
              if (change.type === "added") {
                const data = change.doc.data();
                const sCode = data.sessionCode;
                // Găsim masa care are acest sCode (dacă e activă)
                const idx = this.twelveTables.findIndex(t => t.sessionCode === sCode);
                if (idx !== -1) {
                  // Setăm vibrația
                  this.twelveTables[idx].hasNewOrder = true;
                }
              }
            });
          },
          (err) => {
            console.error("Eroare la onSnapshot orders:", err);
            alert("Nu putem asculta comenzile în timp real!");
          }
        );
      },

      /**
       * Atunci când utilizatorul face click pe o masă (bulină),
       * verificăm dacă masa e ocupată și are un sessionCode.
       * Solicităm introducerea codului, apoi deschidem comanda.
       */
      bubbleClick(tbl) {
        if (!tbl.isOccupied) {
          alert("Masa e goală (nicio sesiune activă)!");
          return;
        }
        const storedCode = this.sessionCodeCache.get(tbl.tableId);
        if (
          storedCode &&
          storedCode.toUpperCase() === tbl.sessionCode.toUpperCase()
        ) {
          // am deja codul stocat, deschid direct
          this.openTable(tbl.tableId, tbl.sessionCode);
        } else {
          // cer user-ului codul
          const code = prompt(`Introduceți codul sesiunii pentru ${tbl.tableId}:`);
          if (!code) return;
          if (code.trim().toUpperCase() !== tbl.sessionCode.toUpperCase()) {
            alert("Cod incorect!");
            return;
          }
          this.updateSessionCache(tbl.tableId, code.trim());
          tbl.sessionCode = code.trim();
          this.openTable(tbl.tableId, code.trim());
        }

        // Oprim "shake" la bulina de masă atunci când chelnerul o deschide
        tbl.hasNewOrder = false;
      },

      /**
       * Deschide masa selectată și începe ascultarea comenzilor doar pentru acel sessionCode.
       */
      openTable(tableId, sessionCode) {
        this.currentTableId = tableId;
        this.currentSessionCode = sessionCode;

        // Oprim vechiul onSnapshot pentru comenzile mesei, dacă exista
        if (this.unsubscribeOrdersForCurrentTable) {
          this.unsubscribeOrdersForCurrentTable();
        }
        this.listenOrdersBySession(sessionCode);
      },

      /**
       * Ascultă în timp real comenzile "open" pentru sessionCode-ul curent,
       * astfel încât să putem afișa lista și butoanele de "Plasează Comanda".
       */
      listenOrdersBySession(sCode) {
        const cRef = collection(db, "orders");
        const qRef = query(cRef, where("sessionCode", "==", sCode), where("status", "==", "open"));

        this.orders = []; // reset
        this.unsubscribeOrdersForCurrentTable = onSnapshot(
          qRef,
          (snapshot) => {
            const newOrders = [];
            let foundNew = false;

            snapshot.forEach(docSnap => {
              const data = docSnap.data();
              const ordId = docSnap.id;

              // E nouă pentru UI?
              if (!this.ordersSeen.has(ordId)) {
                foundNew = true;
                data.isNew = true;
                this.ordersSeen.add(ordId);
              } else {
                data.isNew = false;
              }
              data.orderId = ordId;
              newOrders.push(data);
            });

            this.orders = newOrders;
            localStorage.setItem("ordersSeen", JSON.stringify(Array.from(this.ordersSeen)));

            if (foundNew) {
              this.newOrderHighlight = true;
              setTimeout(() => {
                this.newOrderHighlight = false;
              }, 2000);
            }
          },
          (err) => {
            console.error("Eroare onSnapshot orders by session:", err);
            alert("Nu putem asculta comenzile în timp real pentru această masă!");
          }
        );
      },

      // Schimbă manual o comandă (ex: "pending" -> "placed")
      async placeOrder(orderId) {
        try {
          await updateDoc(doc(db, "orders", orderId), { orderStatus: "placed" });
        } catch (err) {
          console.error("Eroare la placeOrder:", err);
          alert("Nu s-a putut schimba statusul comenzii!");
        }
      },

      /**
       * Finalizează masa -> închide sesiunea + setăm comenzile "open" -> "closed".
       */
      async finalizeTable(tableId) {
        if (!confirm(`Ești sigur că vrei să finalizezi masa ${tableId}?`)) {
          return;
        }
        try {
          // Închidem sesiunea
          const docRef = doc(db, "sessions", tableId);
          await updateDoc(docRef, { sessionCode: null, status: "closed" });

          // Închidem comenzile active
          if (this.currentSessionCode) {
            const cRef = collection(db, "orders");
            const qRef = query(
              cRef,
              where("sessionCode", "==", this.currentSessionCode),
              where("status", "==", "open")
            );
            const snap = await getDocs(qRef);
            for (const docSnap of snap.docs) {
              await updateDoc(doc(db, "orders", docSnap.id), { status: "closed" });
            }
          }

          alert(`Masa ${tableId} a fost închisă!`);
          this.sessionCodeCache.delete(tableId);
          localStorage.setItem(
            "sessionCodeCache",
            JSON.stringify(Array.from(this.sessionCodeCache.entries()))
          );

          this.resetCurrent();
          // Masa va disparea din snapshot-ul "sessions" (că status=closed),
          // ceea ce va reseta isOccupied etc.
        } catch (e) {
          console.error("Eroare la finalizeTable:", e);
          alert("Eroare la finalizarea mesei!");
        }
      },

      updateSessionCache(tableId, code) {
        this.sessionCodeCache.set(tableId, code);
        localStorage.setItem(
          "sessionCodeCache",
          JSON.stringify(Array.from(this.sessionCodeCache.entries()))
        );
      },
      resetCurrent() {
        this.currentTableId = "";
        this.currentSessionCode = "";
        this.orders = [];
        this.newOrderHighlight = false;
        // Oprim onSnapshot dacă există
        if (this.unsubscribeOrdersForCurrentTable) {
          this.unsubscribeOrdersForCurrentTable();
          this.unsubscribeOrdersForCurrentTable = null;
        }
      },
      loadSessionCodeCache() {
        const saved = localStorage.getItem("sessionCodeCache");
        if (saved) {
          try {
            const arr = JSON.parse(saved);
            this.sessionCodeCache = new Map(arr);
          } catch (e) {
            console.warn("Nu s-a putut parsa sessionCodeCache:", e);
          }
        }
      },
      loadOrdersSeen() {
        const saved = localStorage.getItem("ordersSeen");
        if (saved) {
          try {
            const arr = JSON.parse(saved);
            this.ordersSeen = new Set(arr);
          } catch (e) {
            console.warn("Nu s-a putut parsa ordersSeen:", e);
          }
        }
      }
    },
    mounted() {
      // Restaurăm ce s-a salvat anterior
      this.loadSessionCodeCache();
      this.loadOrdersSeen();

      // Ascultăm în timp real toate sesiunile active
      this.subscribeActiveSessions();

      // Ascultăm în timp real toate comenzile "open"
      this.subscribeAllOpenOrders();
    }
  });

  waiterApp.mount("#app");
  </script>
</body>
</html>
